<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MML to SMF Converter - WASM Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        h1 {
            color: #333;
        }
        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .hidden {
            display: none;
        }
        .examples {
            margin: 20px 0;
        }
        .example-button {
            background-color: #17a2b8;
            margin: 5px;
            padding: 5px 10px;
            font-size: 14px;
        }
        .example-button:hover {
            background-color: #138496;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        canvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 10px 0;
            background-color: #000;
        }
        .visualizer-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fafafa;
        }
        .visualizer-section h3 {
            margin-top: 0;
        }
        .playback-controls {
            margin: 20px 0;
        }
        .playback-controls button {
            margin-right: 10px;
        }

        /* Bottom left links */
        .bottom-links {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 12px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        .bottom-links:hover {
            opacity: 1;
        }
        .bottom-links a {
            color: #4CAF50;
            text-decoration: none;
        }
        .bottom-links a:hover {
            text-decoration: underline;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }
            h1 {
                color: #e0e0e0;
            }
            textarea {
                background-color: #2d2d2d;
                color: #e0e0e0;
                border-color: #555;
            }
            button {
                background-color: #3d8b40;
            }
            button:hover {
                background-color: #347a37;
            }
            button:disabled {
                background-color: #555;
            }
            .success {
                background-color: #1a3a1a;
                color: #a8d5a8;
                border-color: #2d5a2d;
            }
            .error {
                background-color: #3a1a1a;
                color: #d5a8a8;
                border-color: #5a2d2d;
            }
            .info {
                background-color: #1a2a3a;
                color: #a8c8d5;
                border-color: #2d4a5a;
            }
            .example-button {
                background-color: #136880;
            }
            .example-button:hover {
                background-color: #0f5670;
            }
            pre {
                background-color: #2d2d2d;
                color: #e0e0e0;
            }
            .bottom-links a {
                color: #3d8b40;
            }
            .visualizer-section {
                background-color: #2d2d2d;
                border-color: #555;
            }
            .visualizer-section h3 {
                color: #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <h1>MML to SMF Converter (WASM)</h1>
    <p>
        This demo converts Music Macro Language (MML) to Standard MIDI File (SMF) format 
        using Rust WASM. It implements Option A: web-tree-sitter parses MML and sends 
        the parse tree JSON to Rust WASM for token extraction and SMF generation.
    </p>

    <div class="examples">
        <strong>Quick Examples:</strong><br>
        <button class="example-button" onclick="loadExample('cde')">Simple Notes</button>
        <button class="example-button" onclick="loadExample('c+d-e')">With Modifiers</button>
        <button class="example-button" onclick="loadExample('c4d8e16')">With Lengths</button>
        <button class="example-button" onclick="loadExample('o5cde')">Octave Set</button>
        <button class="example-button" onclick="loadExample('kt1cde')">Key Transpose</button>
        <button class="example-button" onclick="loadExample('t120@1v100cde')">Full Featured</button>
        <button class="example-button" onclick="loadExample('\'ceg\'')">Chord</button>
        <button class="example-button" onclick="loadExample('c;e;g')">Multi-Channel</button>
    </div>

    <label for="mmlInput"><strong>Enter MML:</strong></label>
    <textarea id="mmlInput" placeholder="Enter MML code here, e.g., cde">cde</textarea>

    <div id="status" class="hidden"></div>

    <div id="debug" class="hidden">
        <h3>Debug Info:</h3>
        <pre id="debugInfo"></pre>
    </div>

    <!-- Playback Controls -->
    <div class="playback-controls" id="playbackControls" style="display: none;">
        <button id="playButton" onclick="playAudio()">‚ñ∂ Play</button>
        <button id="stopButton" onclick="stopAudio()" disabled>‚èπ Stop</button>
        <button id="exportWavButton" onclick="exportWav()">üíæ Export WAV</button>
    </div>

    <!-- Visualizations -->
    <div class="visualizer-section" id="visualizerSection" style="display: none;">
        <h3>Waveform Preview (Full)</h3>
        <canvas id="waveformCanvas" width="760" height="120"></canvas>

        <h3>Real-time Visualization (During Playback)</h3>
        <div style="display: flex; gap: 10px;">
            <div>
                <strong>Waveform:</strong>
                <canvas id="realtimeWaveform" width="370" height="100"></canvas>
            </div>
            <div>
                <strong>FFT Spectrum:</strong>
                <canvas id="realtimeFFT" width="370" height="100"></canvas>
            </div>
        </div>
    </div>

    <!-- JSON Output -->
    <div id="jsonSection" class="hidden">
        <h3>YM2151 Log Format JSON:</h3>
        <pre id="jsonOutput"></pre>
    </div>

    <!-- Bottom left links -->
    <div class="bottom-links">
        <a href="../demo-library/">Library Demo</a>
        <a href="https://github.com/cat2151/mmlabc-to-smf-rust" target="_blank">GitHub Repository</a>
    </div>

    <script type="module">
        // Import web-tree-sitter (local copy)
        import { Parser, Language } from './web-tree-sitter.js';

        // Import WASM module
        import init, { parse_tree_json_to_smf } from '../mmlabc-to-smf-wasm/pkg/mmlabc_to_smf_wasm.js';

        // Import Tone.js (vendored from node_modules during build)
        import * as Tone from './tone.js';

        let parser = null;
        let wasmInitialized = false;
        let debounceTimer = null;
        let currentSmfData = null;
        let currentAudioBuffer = null;
        let audioContext = null;
        let audioSource = null;
        let animationId = null;

        // Initialize everything
        async function initialize() {
            try {
                // Initialize web-tree-sitter
                await Parser.init();
                parser = new Parser();
                
                // Load MML grammar
                const lang = await Language.load('../tree-sitter-mml/tree-sitter-mml.wasm');
                parser.setLanguage(lang);
                
                // Initialize Rust WASM
                await init();
                wasmInitialized = true;
                
                showStatus('Ready! Parser and WASM initialized.', 'success');
                
                // Set up automatic conversion on input
                const mmlInput = document.getElementById('mmlInput');
                mmlInput.addEventListener('input', () => {
                    // Clear existing timer
                    if (debounceTimer) {
                        clearTimeout(debounceTimer);
                    }
                    // Set new timer for 500ms after user stops typing
                    debounceTimer = setTimeout(() => {
                        convertMML();
                    }, 500);
                });
                
                // Convert initial content
                convertMML();
            } catch (error) {
                showStatus('Error initializing: ' + error.message, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Convert parse tree to JSON
        function treeToJSON(node, source) {
            const result = {
                type: node.type,
            };
            
            // Add text for leaf nodes
            if (node.childCount === 0) {
                result.text = source.substring(node.startIndex, node.endIndex);
            }
            
            // Add children for non-leaf nodes
            if (node.childCount > 0) {
                result.children = [];
                for (let i = 0; i < node.childCount; i++) {
                    result.children.push(treeToJSON(node.child(i), source));
                }
            }
            
            return result;
        }

        // Convert MML to SMF
        window.convertMML = async function() {
            if (!wasmInitialized || !parser) {
                showStatus('Not initialized yet. Please wait...', 'error');
                return;
            }

            const mml = document.getElementById('mmlInput').value.trim();
            
            if (!mml) {
                // For empty input during automatic conversion, clear status/debug instead of showing an error
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = '';
                statusDiv.className = 'hidden';

                const debugSection = document.getElementById('debug');
                if (debugSection) {
                    debugSection.classList.add('hidden');
                }
                const debugInfo = document.getElementById('debugInfo');
                if (debugInfo) {
                    debugInfo.textContent = '';
                }
                return;
            }

            try {
                showStatus('Parsing MML...', 'info');
                
                // Parse MML using web-tree-sitter
                const tree = parser.parse(mml);
                
                // Convert parse tree to JSON
                const parseTreeJSON = treeToJSON(tree.rootNode, mml);
                const parseTreeStr = JSON.stringify(parseTreeJSON);
                
                // Show debug info
                document.getElementById('debugInfo').textContent = 
                    'Parse Tree JSON:\n' + JSON.stringify(parseTreeJSON, null, 2);
                document.getElementById('debug').classList.remove('hidden');
                
                showStatus('Converting to SMF via Rust WASM...', 'info');
                
                // Call Rust WASM to convert parse tree to SMF
                const smfData = parse_tree_json_to_smf(parseTreeStr, mml);
                currentSmfData = smfData;

                // Convert SMF to YM2151 JSON format (simplified)
                const ym2151Json = smfToYM2151Json(smfData);
                document.getElementById('jsonOutput').textContent = JSON.stringify(ym2151Json, null, 2);
                document.getElementById('jsonSection').classList.remove('hidden');

                // Render waveform and prepare audio
                await renderWaveformAndAudio(smfData);

                // Create download link
                const blob = new Blob([smfData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.mid';
                a.textContent = 'Download MIDI File';

                showStatus('‚úÖ Conversion successful! SMF size: ' + smfData.length + ' bytes', 'success');
                const statusDiv = document.getElementById('status');
                statusDiv.appendChild(document.createElement('br'));
                statusDiv.appendChild(a);

                // Show playback controls
                document.getElementById('playbackControls').style.display = 'block';
                document.getElementById('visualizerSection').style.display = 'block';

            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                console.error('Conversion error:', error);
            }
        };

        // Load example MML
        window.loadExample = function(example) {
            const input = document.getElementById('mmlInput');
            input.value = example;
            // Trigger input event to start automatic conversion
            input.dispatchEvent(new Event('input'));
        };

        // Cleanup debounce timer when page is unloaded
        window.addEventListener('beforeunload', () => {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
                debounceTimer = null;
            }
        });

        // Show status message
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.classList.remove('hidden');
        }

        // Convert SMF to YM2151 JSON format (simplified)
        function smfToYM2151Json(smfData) {
            // Parse basic MIDI information and convert to YM2151 event format
            // This is a simplified version - real YM2151 would need more complex mapping
            const events = [];

            try {
                // Simple parsing of MIDI note events
                // Look for note on/off events (0x90, 0x80)
                let time = 0.0;

                for (let i = 0; i < smfData.length - 2; i++) {
                    const status = smfData[i];

                    // Note On (0x90-0x9F)
                    if ((status & 0xF0) === 0x90) {
                        const note = smfData[i + 1];
                        const velocity = smfData[i + 2];

                        if (velocity > 0) {
                            // Simplified YM2151 register writes for note on
                            events.push({
                                time: time,
                                address: 0x08,  // Key control
                                data: 0x78      // Key on
                            });
                            events.push({
                                time: time + 0.001,
                                address: 0x28,  // Key fraction
                                data: 0x00
                            });
                            events.push({
                                time: time + 0.002,
                                address: 0x30,  // Key code
                                data: Math.floor(note / 12) << 4 | (note % 12)
                            });
                        }
                        time += 0.1; // Simplified timing
                    }
                    // Note Off (0x80-0x8F)
                    else if ((status & 0xF0) === 0x80) {
                        events.push({
                            time: time,
                            address: 0x08,
                            data: 0x00  // Key off
                        });
                        time += 0.1;
                    }
                }
            } catch (e) {
                console.warn('Error parsing MIDI:', e);
            }

            return { events: events };
        }

        // Render waveform and prepare audio
        async function renderWaveformAndAudio(smfData) {
            try {
                // Initialize audio context
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Parse MIDI and generate audio
                const audioData = await midiToAudio(smfData);

                // Create audio buffer
                currentAudioBuffer = audioContext.createBuffer(
                    2,  // stereo
                    audioData.left.length,
                    44100  // sample rate
                );

                currentAudioBuffer.getChannelData(0).set(audioData.left);
                currentAudioBuffer.getChannelData(1).set(audioData.right);

                // Draw waveform
                drawWaveform(audioData.left);

            } catch (error) {
                console.error('Error rendering waveform:', error);
            }
        }

        // Simple MIDI to audio conversion using sine waves
        async function midiToAudio(smfData) {
            const sampleRate = 44100;
            const duration = 3.0; // seconds
            const numSamples = Math.floor(sampleRate * duration);

            const left = new Float32Array(numSamples);
            const right = new Float32Array(numSamples);

            // Parse MIDI and generate tones
            const notes = [];
            for (let i = 0; i < smfData.length - 2; i++) {
                const status = smfData[i];

                if ((status & 0xF0) === 0x90) {  // Note on
                    const note = smfData[i + 1];
                    const velocity = smfData[i + 2];

                    if (velocity > 0) {
                        notes.push({
                            note: note,
                            velocity: velocity / 127.0,
                            start: notes.length * 0.3,
                            duration: 0.25
                        });
                    }
                }
            }

            // Generate sine waves for each note
            for (const noteInfo of notes) {
                const freq = 440 * Math.pow(2, (noteInfo.note - 69) / 12);
                const startSample = Math.floor(noteInfo.start * sampleRate);
                const durationSamples = Math.floor(noteInfo.duration * sampleRate);

                for (let i = 0; i < durationSamples; i++) {
                    const sampleIndex = startSample + i;
                    if (sampleIndex < numSamples) {
                        const t = i / sampleRate;
                        const envelope = Math.exp(-3 * t);  // Simple exponential decay
                        const value = Math.sin(2 * Math.PI * freq * t) * envelope * noteInfo.velocity * 0.3;

                        left[sampleIndex] += value;
                        right[sampleIndex] += value;
                    }
                }
            }

            return { left, right };
        }

        // Draw waveform on canvas
        function drawWaveform(audioData) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();

            const step = Math.floor(audioData.length / width);

            for (let i = 0; i < width; i++) {
                const index = i * step;
                const value = audioData[index] || 0;
                const y = (value * 0.5 + 0.5) * height;

                if (i === 0) {
                    ctx.moveTo(i, y);
                } else {
                    ctx.lineTo(i, y);
                }
            }

            ctx.stroke();
        }

        // Play audio with visualization
        window.playAudio = async function() {
            if (!currentAudioBuffer) {
                showStatus('No audio to play. Please convert MML first.', 'error');
                return;
            }

            try {
                // Stop any existing playback
                stopAudio();

                // Start Tone.js context
                await Tone.start();

                // Create player
                const player = new Tone.Player({
                    buffer: currentAudioBuffer,
                    loop: false
                }).toDestination();

                // Create analyzers for visualization
                const waveform = new Tone.Waveform(1024);
                const fft = new Tone.FFT(512);

                player.connect(waveform);
                player.connect(fft);

                // Start playback
                player.start();

                // Update UI
                document.getElementById('playButton').disabled = true;
                document.getElementById('stopButton').disabled = false;

                // Start visualization
                visualizeRealtime(waveform, fft);

                // Re-enable play button when done
                player.onstop = () => {
                    document.getElementById('playButton').disabled = false;
                    document.getElementById('stopButton').disabled = true;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                };

                audioSource = player;

            } catch (error) {
                console.error('Error playing audio:', error);
                showStatus('Error playing audio: ' + error.message, 'error');
            }
        };

        // Stop audio playback
        window.stopAudio = function() {
            if (audioSource) {
                try {
                    audioSource.stop();
                } catch (e) {
                    // Ignore errors
                }
                audioSource = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            document.getElementById('playButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
        };

        // Real-time visualization at 60fps
        function visualizeRealtime(waveform, fft) {
            const waveCanvas = document.getElementById('realtimeWaveform');
            const fftCanvas = document.getElementById('realtimeFFT');
            const waveCtx = waveCanvas.getContext('2d');
            const fftCtx = fftCanvas.getContext('2d');

            function draw() {
                // Draw waveform
                const waveformValues = waveform.getValue();
                waveCtx.fillStyle = '#000';
                waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);

                waveCtx.strokeStyle = '#0f0';
                waveCtx.lineWidth = 2;
                waveCtx.beginPath();

                for (let i = 0; i < waveformValues.length; i++) {
                    const x = i * (waveCanvas.width / waveformValues.length);
                    const y = (1 - (waveformValues[i] + 1) / 2) * waveCanvas.height;

                    if (i === 0) {
                        waveCtx.moveTo(x, y);
                    } else {
                        waveCtx.lineTo(x, y);
                    }
                }
                waveCtx.stroke();

                // Draw FFT
                const fftValues = fft.getValue();
                fftCtx.fillStyle = '#000';
                fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);

                const barWidth = fftCanvas.width / fftValues.length;

                for (let i = 0; i < fftValues.length; i++) {
                    const value = fftValues[i];
                    const percent = (value + 140) / 140;  // Normalize dB value
                    const barHeight = percent * fftCanvas.height;
                    const hue = (i / fftValues.length) * 360;

                    fftCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    fftCtx.fillRect(
                        i * barWidth,
                        fftCanvas.height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }

                animationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Export WAV file
        window.exportWav = function() {
            if (!currentAudioBuffer) {
                showStatus('No audio to export. Please convert MML first.', 'error');
                return;
            }

            try {
                const wavData = audioBufferToWav(currentAudioBuffer);
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.wav';
                a.click();

                // Revoke URL after a short delay to ensure download has started
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
                showStatus('WAV file exported successfully!', 'success');
            } catch (error) {
                console.error('Error exporting WAV:', error);
                showStatus('Error exporting WAV: ' + error.message, 'error');
            }
        };

        // Convert AudioBuffer to WAV format
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataLength = buffer.length * numChannels * bytesPerSample;

            const buffer_out = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer_out);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);  // chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);  // byte rate
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            // Write PCM data directly to output buffer
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = buffer.getChannelData(channel)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    const pcmValue = Math.floor(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
                    view.setInt16(offset, pcmValue, true);
                    offset += 2;
                }
            }

            return buffer_out;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Initialize on page load
        initialize();
    </script>
</body>
</html>
