//! WASM-specific module for MML to SMF conversion
//!
//! This module provides a WASM-compatible interface for converting
//! parsed MML tokens to SMF binary data. It bypasses Pass 1 (tree-sitter parsing)
//! to avoid C dependency issues in WASM.
//!
//! # Safety
//!
//! This module uses mutable static variables for storing conversion results.
//! It is designed for single-threaded WASM environments (typical for browser usage).
//! Do NOT use this module in multi-threaded contexts as it will cause data races.
//!
//! # Memory Management
//!
//! Error strings returned by `get_last_error()` are automatically managed and
//! cached. They are freed automatically on the next conversion attempt.
//! Callers do NOT need to (and should NOT) call `free_error_string()` on these pointers.

use crate::{pass2_ast, pass3_events, pass4_midi, types::Token};
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};
use std::ptr;

// Thread-local storage for the last generated MIDI data
static mut LAST_MIDI_DATA: Option<Vec<u8>> = None;
static mut LAST_ERROR: Option<String> = None;
static mut LAST_ERROR_PTR: *mut c_char = ptr::null_mut();

/// Convert MML tokens (as JSON string) to SMF binary buffer
///
/// This function takes pre-parsed MML tokens in JSON format and converts them
/// to SMF data. The parsing (Pass 1) must be done outside of WASM.
///
/// # Arguments
/// * `tokens_json_ptr` - Pointer to null-terminated JSON string containing tokens
///
/// # Returns
/// * Length of generated MIDI data on success, -1 on error
#[no_mangle]
pub extern "C" fn tokens_to_smf(tokens_json_ptr: *const c_char) -> c_int {
    // Clear previous data and free previous error string if any
    unsafe {
        LAST_MIDI_DATA = None;
        LAST_ERROR = None;
        if !LAST_ERROR_PTR.is_null() {
            let _ = CString::from_raw(LAST_ERROR_PTR);
            LAST_ERROR_PTR = ptr::null_mut();
        }
    }

    // Validate input pointer
    if tokens_json_ptr.is_null() {
        unsafe {
            LAST_ERROR = Some("Null pointer provided".to_string());
        }
        return -1;
    }

    // Convert C string to Rust string
    let tokens_json = unsafe {
        match CStr::from_ptr(tokens_json_ptr).to_str() {
            Ok(s) => s,
            Err(e) => {
                LAST_ERROR = Some(format!("Invalid UTF-8 string: {}", e));
                return -1;
            }
        }
    };

    // Parse JSON tokens
    let tokens: Vec<Token> = match serde_json::from_str(tokens_json) {
        Ok(t) => t,
        Err(e) => {
            unsafe {
                LAST_ERROR = Some(format!("JSON parse error: {}", e));
            }
            return -1;
        }
    };

    // Process tokens through passes 2-4
    let result = process_tokens_to_bytes(&tokens);

    match result {
        Ok(midi_data) => {
            let len = midi_data.len() as c_int;
            unsafe {
                LAST_MIDI_DATA = Some(midi_data);
            }
            len
        }
        Err(e) => {
            unsafe {
                LAST_ERROR = Some(format!("Conversion error: {}", e));
            }
            -1
        }
    }
}

/// Get pointer to the last generated MIDI data
///
/// This function returns a pointer to the MIDI data generated by the last
/// call to tokens_to_smf(). The data remains valid until the next call.
///
/// # Returns
/// * Pointer to MIDI data, or null pointer if no data available
#[no_mangle]
pub extern "C" fn get_midi_data() -> *const u8 {
    unsafe {
        match &LAST_MIDI_DATA {
            Some(data) => data.as_ptr(),
            None => ptr::null(),
        }
    }
}

/// Get length of the last generated MIDI data
///
/// # Returns
/// * Length of MIDI data, or 0 if no data available
#[no_mangle]
pub extern "C" fn get_midi_data_length() -> c_int {
    unsafe {
        match &LAST_MIDI_DATA {
            Some(data) => data.len() as c_int,
            None => 0,
        }
    }
}

/// Get error message for the last operation
///
/// **Important**: The returned string is cached and reused on subsequent calls.
/// You should NOT call `free_error_string()` on this pointer - it will be
/// automatically freed on the next conversion attempt or when a new error occurs.
/// If you need to store the error message, copy it to your own buffer.
///
/// This function can be called multiple times for the same error without
/// causing memory leaks - it will return the same pointer each time.
///
/// # Returns
/// * Pointer to null-terminated error string, or null if no error
#[no_mangle]
pub extern "C" fn get_last_error() -> *const c_char {
    unsafe {
        // If we already have a cached error pointer, return it
        if !LAST_ERROR_PTR.is_null() {
            return LAST_ERROR_PTR;
        }

        // Otherwise, create a new error string if we have an error
        match &LAST_ERROR {
            Some(err) => {
                let c_str = CString::new(err.as_str())
                    .unwrap_or_else(|_| CString::new("Error converting error message").unwrap());
                LAST_ERROR_PTR = c_str.into_raw();
                LAST_ERROR_PTR
            }
            None => ptr::null(),
        }
    }
}

/// Free the error string returned by get_last_error
///
/// **Note**: This function is deprecated and should not be used with the current
/// implementation. The error string is automatically managed and freed on the
/// next conversion attempt. This function is kept for backward compatibility
/// but does nothing.
///
/// # Arguments
/// * `ptr` - Pointer returned by get_last_error() (ignored)
#[no_mangle]
pub extern "C" fn free_error_string(_ptr: *mut c_char) {
    // No-op: error string is now managed automatically and freed in tokens_to_smf
    // Kept for backward compatibility
}

/// Internal function to process tokens to MIDI bytes (Passes 2-4)
fn process_tokens_to_bytes(tokens: &[Token]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // Pass 2: Convert tokens to AST
    let ast = pass2_ast::tokens_to_ast(tokens);

    // Pass 3: Convert AST to MIDI events
    let events = pass3_events::ast_to_events(&ast);

    // Pass 4: Convert events to SMF bytes
    let midi_data = pass4_midi::events_to_midi(&events)?;

    Ok(midi_data)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::CString;

    #[test]
    fn test_tokens_to_smf_basic() {
        // Create a simple token list
        let tokens = vec![Token {
            token_type: "note".to_string(),
            value: "c".to_string(),
            channel_group: None,
            chord_id: None,
            modifier: None,
            note_length: None,
            dots: None,
        }];

        let tokens_json = serde_json::to_string(&tokens).unwrap();
        let c_tokens = CString::new(tokens_json).unwrap();

        let len = tokens_to_smf(c_tokens.as_ptr());
        assert!(len > 0, "Should generate MIDI data");

        let data_ptr = get_midi_data();
        assert!(!data_ptr.is_null(), "Should have MIDI data pointer");

        let data_len = get_midi_data_length();
        assert_eq!(len, data_len, "Lengths should match");
    }

    #[test]
    fn test_tokens_to_smf_null_pointer() {
        let len = tokens_to_smf(ptr::null());
        assert_eq!(len, -1, "Should return -1 for null pointer");
    }

    #[test]
    fn test_tokens_to_smf_invalid_json() {
        let invalid_json = CString::new("not valid json").unwrap();
        let len = tokens_to_smf(invalid_json.as_ptr());
        assert_eq!(len, -1, "Should return -1 for invalid JSON");

        let error_ptr = get_last_error();
        assert!(!error_ptr.is_null(), "Should have error message");

        // Call get_last_error again to verify it returns the same pointer (cached)
        let error_ptr2 = get_last_error();
        assert_eq!(error_ptr, error_ptr2, "Should return cached error pointer");
    }

    #[test]
    fn test_error_string_lifecycle() {
        // First error
        let invalid_json = CString::new("not valid json").unwrap();
        let _ = tokens_to_smf(invalid_json.as_ptr());
        let error_ptr1 = get_last_error();
        assert!(!error_ptr1.is_null(), "Should have first error message");

        // Second conversion with different error - should free old error and create new one
        let _ = tokens_to_smf(ptr::null());
        let error_ptr2 = get_last_error();
        assert!(!error_ptr2.is_null(), "Should have second error message");

        // Pointers should be different (old one was freed, new one allocated)
        // Note: They might be the same if allocator reuses memory, so we just check both are valid
        assert!(
            !error_ptr1.is_null() && !error_ptr2.is_null(),
            "Both error pointers should be valid"
        );
    }
}
