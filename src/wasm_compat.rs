//! WASM-specific module for MML to SMF conversion
//!
//! This module provides a WASM-compatible interface for converting
//! parsed MML tokens to SMF binary data. It bypasses Pass 1 (tree-sitter parsing)
//! to avoid C dependency issues in WASM.

use crate::{pass2_ast, pass3_events, pass4_midi, types::Token};
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};
use std::ptr;

// Thread-local storage for the last generated MIDI data
static mut LAST_MIDI_DATA: Option<Vec<u8>> = None;
static mut LAST_ERROR: Option<String> = None;

/// Convert MML tokens (as JSON string) to SMF binary buffer
///
/// This function takes pre-parsed MML tokens in JSON format and converts them
/// to SMF data. The parsing (Pass 1) must be done outside of WASM.
///
/// # Arguments
/// * `tokens_json_ptr` - Pointer to null-terminated JSON string containing tokens
///
/// # Returns
/// * Length of generated MIDI data on success, -1 on error
#[no_mangle]
pub extern "C" fn tokens_to_smf(tokens_json_ptr: *const c_char) -> c_int {
    // Clear previous data
    unsafe {
        LAST_MIDI_DATA = None;
        LAST_ERROR = None;
    }

    // Validate input pointer
    if tokens_json_ptr.is_null() {
        unsafe {
            LAST_ERROR = Some("Null pointer provided".to_string());
        }
        return -1;
    }

    // Convert C string to Rust string
    let tokens_json = unsafe {
        match CStr::from_ptr(tokens_json_ptr).to_str() {
            Ok(s) => s,
            Err(e) => {
                LAST_ERROR = Some(format!("Invalid UTF-8 string: {}", e));
                return -1;
            }
        }
    };

    // Parse JSON tokens
    let tokens: Vec<Token> = match serde_json::from_str(tokens_json) {
        Ok(t) => t,
        Err(e) => {
            unsafe {
                LAST_ERROR = Some(format!("JSON parse error: {}", e));
            }
            return -1;
        }
    };

    // Process tokens through passes 2-4
    let result = process_tokens_to_bytes(&tokens);

    match result {
        Ok(midi_data) => {
            let len = midi_data.len() as c_int;
            unsafe {
                LAST_MIDI_DATA = Some(midi_data);
            }
            len
        }
        Err(e) => {
            unsafe {
                LAST_ERROR = Some(format!("Conversion error: {}", e));
            }
            -1
        }
    }
}

/// Get pointer to the last generated MIDI data
///
/// This function returns a pointer to the MIDI data generated by the last
/// call to tokens_to_smf(). The data remains valid until the next call.
///
/// # Returns
/// * Pointer to MIDI data, or null pointer if no data available
#[no_mangle]
pub extern "C" fn get_midi_data() -> *const u8 {
    unsafe {
        match &LAST_MIDI_DATA {
            Some(data) => data.as_ptr(),
            None => ptr::null(),
        }
    }
}

/// Get length of the last generated MIDI data
///
/// # Returns
/// * Length of MIDI data, or 0 if no data available
#[no_mangle]
pub extern "C" fn get_midi_data_length() -> c_int {
    unsafe {
        match &LAST_MIDI_DATA {
            Some(data) => data.len() as c_int,
            None => 0,
        }
    }
}

/// Get error message for the last operation
///
/// # Returns
/// * Pointer to null-terminated error string, or null if no error
#[no_mangle]
pub extern "C" fn get_last_error() -> *const c_char {
    unsafe {
        match &LAST_ERROR {
            Some(err) => {
                let c_str = CString::new(err.as_str())
                    .unwrap_or_else(|_| CString::new("Error converting error message").unwrap());
                c_str.into_raw()
            }
            None => ptr::null(),
        }
    }
}

/// Free the error string returned by get_last_error
///
/// # Arguments
/// * `ptr` - Pointer returned by get_last_error()
#[no_mangle]
pub extern "C" fn free_error_string(ptr: *mut c_char) {
    if !ptr.is_null() {
        unsafe {
            let _ = CString::from_raw(ptr);
        }
    }
}

/// Internal function to process tokens to MIDI bytes (Passes 2-4)
fn process_tokens_to_bytes(tokens: &[Token]) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
    // Pass 2: Convert tokens to AST
    let ast = pass2_ast::tokens_to_ast(tokens);

    // Pass 3: Convert AST to MIDI events
    let events = pass3_events::ast_to_events(&ast);

    // Pass 4: Convert events to SMF bytes
    let midi_data = pass4_midi::events_to_midi(&events)?;

    Ok(midi_data)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::CString;

    #[test]
    fn test_tokens_to_smf_basic() {
        // Create a simple token list
        let tokens = vec![Token {
            token_type: "note".to_string(),
            value: "c".to_string(),
            channel_group: None,
            chord_id: None,
            modifier: None,
            note_length: None,
            dots: None,
        }];

        let tokens_json = serde_json::to_string(&tokens).unwrap();
        let c_tokens = CString::new(tokens_json).unwrap();

        let len = tokens_to_smf(c_tokens.as_ptr());
        assert!(len > 0, "Should generate MIDI data");

        let data_ptr = get_midi_data();
        assert!(!data_ptr.is_null(), "Should have MIDI data pointer");

        let data_len = get_midi_data_length();
        assert_eq!(len, data_len, "Lengths should match");
    }

    #[test]
    fn test_tokens_to_smf_null_pointer() {
        let len = tokens_to_smf(ptr::null());
        assert_eq!(len, -1, "Should return -1 for null pointer");
    }

    #[test]
    fn test_tokens_to_smf_invalid_json() {
        let invalid_json = CString::new("not valid json").unwrap();
        let len = tokens_to_smf(invalid_json.as_ptr());
        assert_eq!(len, -1, "Should return -1 for invalid JSON");

        let error_ptr = get_last_error();
        assert!(!error_ptr.is_null(), "Should have error message");
    }
}
