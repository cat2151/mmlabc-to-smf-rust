//! WASM bindings for MML to SMF conversion
//! 
//! This module provides WASM bindings for converting MML tokens to Standard MIDI Files.
//! The parsing (Pass 1) is done in JavaScript using web-tree-sitter,
//! while this module handles Pass 2-4 (AST, Events, MIDI generation).

use wasm_bindgen::prelude::*;

mod types;
mod pass2_ast;
mod pass3_events;
mod pass4_midi;

use types::Token;

/// Convert MML tokens to SMF binary data
/// 
/// This function takes tokens (generated by tree-sitter parsing in JavaScript)
/// and converts them through the 4-pass architecture to produce a Standard MIDI File.
/// 
/// # Arguments
/// * `tokens_json` - JSON string containing the tokens from Pass 1
/// 
/// # Returns
/// SMF binary data as a Uint8Array
#[wasm_bindgen]
pub fn mml_to_smf(tokens_json: &str) -> Result<Vec<u8>, JsValue> {
    // Parse tokens from JSON
    let tokens: Vec<Token> = serde_json::from_str(tokens_json)
        .map_err(|e| JsValue::from_str(&format!("Failed to parse tokens: {}", e)))?;

    // Pass 2: Convert tokens to AST
    let ast = pass2_ast::tokens_to_ast(&tokens);

    // Pass 3: Convert AST to MIDI events
    let events = pass3_events::ast_to_events(&ast);

    // Pass 4: Convert events to SMF binary
    let midi_data = pass4_midi::events_to_midi(&events)
        .map_err(|e| JsValue::from_str(&format!("Pass 4 failed: {}", e)))?;

    Ok(midi_data)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(target_arch = "wasm32")]
    fn test_mml_to_smf_basic() {
        let tokens_json = r#"[
            {"type":"note","value":"c"},
            {"type":"note","value":"d"},
            {"type":"note","value":"e"}
        ]"#;

        let result = mml_to_smf(tokens_json);
        assert!(result.is_ok());
        
        let midi_data = result.unwrap();
        assert!(!midi_data.is_empty());
        
        // Check MIDI header signature "MThd"
        assert_eq!(&midi_data[0..4], b"MThd");
    }
    
    // Test the underlying conversion logic (not the wasm-bindgen wrapper)
    #[test]
    #[cfg(not(target_arch = "wasm32"))]
    fn test_conversion_logic() {
        use crate::{pass2_ast, pass3_events, pass4_midi, types::Token};
        
        let tokens = vec![
            Token {
                token_type: "note".to_string(),
                value: "c".to_string(),
                channel_group: None,
                chord_id: None,
                modifier: None,
                note_length: None,
                dots: None,
            },
            Token {
                token_type: "note".to_string(),
                value: "d".to_string(),
                channel_group: None,
                chord_id: None,
                modifier: None,
                note_length: None,
                dots: None,
            },
            Token {
                token_type: "note".to_string(),
                value: "e".to_string(),
                channel_group: None,
                chord_id: None,
                modifier: None,
                note_length: None,
                dots: None,
            },
        ];

        let ast = pass2_ast::tokens_to_ast(&tokens);
        assert_eq!(ast.notes.len(), 3);

        let events = pass3_events::ast_to_events(&ast);
        assert!(!events.is_empty());

        let midi_data = pass4_midi::events_to_midi(&events);
        assert!(midi_data.is_ok());
        
        let data = midi_data.unwrap();
        assert!(!data.is_empty());
        assert_eq!(&data[0..4], b"MThd");
    }
}
