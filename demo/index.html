<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MML to SMF Converter - WASM Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        h1 {
            color: #333;
        }
        textarea {
            width: 100%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .hidden {
            display: none;
        }
        .examples {
            margin: 20px 0;
        }
        .example-button {
            background-color: #17a2b8;
            margin: 5px;
            padding: 5px 10px;
            font-size: 14px;
        }
        .example-button:hover {
            background-color: #138496;
        }
        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        canvas {
            border: 1px solid #ccc;
            border-radius: 4px;
            margin: 10px 0;
            background-color: #000;
        }
        .visualizer-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fafafa;
        }
        .visualizer-section h3 {
            margin-top: 0;
        }
        .playback-controls {
            margin: 20px 0;
        }
        .playback-controls button {
            margin-right: 10px;
        }

        /* Bottom left links */
        .bottom-links {
            position: fixed;
            bottom: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 12px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        .bottom-links:hover {
            opacity: 1;
        }
        .bottom-links a {
            color: #4CAF50;
            text-decoration: none;
        }
        .bottom-links a:hover {
            text-decoration: underline;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
                color: #e0e0e0;
            }
            h1 {
                color: #e0e0e0;
            }
            textarea {
                background-color: #2d2d2d;
                color: #e0e0e0;
                border-color: #555;
            }
            button {
                background-color: #3d8b40;
            }
            button:hover {
                background-color: #347a37;
            }
            button:disabled {
                background-color: #555;
            }
            .success {
                background-color: #1a3a1a;
                color: #a8d5a8;
                border-color: #2d5a2d;
            }
            .error {
                background-color: #3a1a1a;
                color: #d5a8a8;
                border-color: #5a2d2d;
            }
            .info {
                background-color: #1a2a3a;
                color: #a8c8d5;
                border-color: #2d4a5a;
            }
            .example-button {
                background-color: #136880;
            }
            .example-button:hover {
                background-color: #0f5670;
            }
            pre {
                background-color: #2d2d2d;
                color: #e0e0e0;
            }
            .bottom-links a {
                color: #3d8b40;
            }
            .visualizer-section {
                background-color: #2d2d2d;
                border-color: #555;
            }
            .visualizer-section h3 {
                color: #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <h1>MML to SMF Converter (WASM)</h1>
    <p>
        This demo converts Music Macro Language (MML) to Standard MIDI File (SMF) format 
        using Rust WASM. It implements Option A: web-tree-sitter parses MML and sends 
        the parse tree JSON to Rust WASM for token extraction and SMF generation.
    </p>

    <div class="examples">
        <strong>Quick Examples:</strong><br>
        <button class="example-button" onclick="loadExample('cde')">Simple Notes</button>
        <button class="example-button" onclick="loadExample('c+d-e')">With Modifiers</button>
        <button class="example-button" onclick="loadExample('c4d8e16')">With Lengths</button>
        <button class="example-button" onclick="loadExample('o5cde')">Octave Set</button>
        <button class="example-button" onclick="loadExample('kt1cde')">Key Transpose</button>
        <button class="example-button" onclick="loadExample('t120@1v100cde')">Full Featured</button>
        <button class="example-button" onclick="loadExample('\'ceg\'')">Chord</button>
        <button class="example-button" onclick="loadExample('c;e;g')">Multi-Channel</button>
    </div>

    <label for="mmlInput"><strong>Enter MML:</strong></label>
    <textarea id="mmlInput" placeholder="Enter MML code here, e.g., cde">cde</textarea>

    <div id="status" class="hidden"></div>

    <div id="debug" class="hidden">
        <h3>Debug Info:</h3>
        <pre id="debugInfo"></pre>
    </div>

    <!-- Playback Controls -->
    <div class="playback-controls" id="playbackControls" style="display: none;">
        <button id="playButton" onclick="playAudio()">‚ñ∂ Play</button>
        <button id="stopButton" onclick="stopAudio()" disabled>‚èπ Stop</button>
        <button id="exportWavButton" onclick="exportWav()">üíæ Export WAV</button>
    </div>

    <!-- Visualizations -->
    <div class="visualizer-section" id="visualizerSection" style="display: none;">
        <h3>Waveform Preview (Full)</h3>
        <canvas id="waveformCanvas" width="760" height="120"></canvas>

        <h3>Real-time Visualization (During Playback)</h3>
        <div style="display: flex; gap: 10px;">
            <div>
                <strong>Waveform:</strong>
                <canvas id="realtimeWaveform" width="370" height="100"></canvas>
            </div>
            <div>
                <strong>FFT Spectrum:</strong>
                <canvas id="realtimeFFT" width="370" height="100"></canvas>
            </div>
        </div>
    </div>

    <!-- JSON Output -->
    <div id="jsonSection" class="hidden">
        <h3>YM2151 Log Format JSON:</h3>
        <pre id="jsonOutput"></pre>
    </div>

    <!-- Bottom left links -->
    <div class="bottom-links">
        <a href="../demo-library/">Library Demo</a>
        <a href="https://github.com/cat2151/mmlabc-to-smf-rust" target="_blank">GitHub Repository</a>
    </div>

    <script type="module">
        // Import web-tree-sitter (local copy)
        import { Parser, Language } from './web-tree-sitter.js';

        // Import WASM module
        import init, { parse_tree_json_to_smf } from '../mmlabc-to-smf-wasm/pkg/mmlabc_to_smf_wasm.js';

        // Import Tone.js (vendored ESM directory from node_modules during build)
        import * as Tone from './tone/index.js';

        let parser = null;
        let wasmInitialized = false;
        let debounceTimer = null;
        let currentSmfData = null;
        let currentAudioBuffer = null;
        let audioContext = null;
        let audioSource = null;
        let animationId = null;

        // Initialize everything
        async function initialize() {
            try {
                // Initialize web-tree-sitter
                await Parser.init();
                parser = new Parser();
                
                // Load MML grammar
                const lang = await Language.load('../tree-sitter-mml/tree-sitter-mml.wasm');
                parser.setLanguage(lang);
                
                // Initialize Rust WASM
                await init();
                wasmInitialized = true;
                
                showStatus('Ready! Parser and WASM initialized.', 'success');
                
                // Set up automatic conversion on input
                const mmlInput = document.getElementById('mmlInput');
                mmlInput.addEventListener('input', () => {
                    // Clear existing timer
                    if (debounceTimer) {
                        clearTimeout(debounceTimer);
                    }
                    // Set new timer for 500ms after user stops typing
                    debounceTimer = setTimeout(() => {
                        convertMML();
                    }, 500);
                });
                
                // Convert initial content
                convertMML();
            } catch (error) {
                showStatus('Error initializing: ' + error.message, 'error');
                console.error('Initialization error:', error);
            }
        }

        // Convert parse tree to JSON
        function treeToJSON(node, source) {
            const result = {
                type: node.type,
            };
            
            // Add text for leaf nodes
            if (node.childCount === 0) {
                result.text = source.substring(node.startIndex, node.endIndex);
            }
            
            // Add children for non-leaf nodes
            if (node.childCount > 0) {
                result.children = [];
                for (let i = 0; i < node.childCount; i++) {
                    result.children.push(treeToJSON(node.child(i), source));
                }
            }
            
            return result;
        }

        // Convert MML to SMF
        window.convertMML = async function() {
            if (!wasmInitialized || !parser) {
                showStatus('Not initialized yet. Please wait...', 'error');
                return;
            }

            const mml = document.getElementById('mmlInput').value.trim();
            
            if (!mml) {
                // For empty input during automatic conversion, clear status/debug instead of showing an error
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = '';
                statusDiv.className = 'hidden';

                const debugSection = document.getElementById('debug');
                if (debugSection) {
                    debugSection.classList.add('hidden');
                }
                const debugInfo = document.getElementById('debugInfo');
                if (debugInfo) {
                    debugInfo.textContent = '';
                }
                return;
            }

            try {
                showStatus('Parsing MML...', 'info');
                
                // Parse MML using web-tree-sitter
                const tree = parser.parse(mml);
                
                // Convert parse tree to JSON
                const parseTreeJSON = treeToJSON(tree.rootNode, mml);
                const parseTreeStr = JSON.stringify(parseTreeJSON);
                
                // Show debug info
                document.getElementById('debugInfo').textContent = 
                    'Parse Tree JSON:\n' + JSON.stringify(parseTreeJSON, null, 2);
                document.getElementById('debug').classList.remove('hidden');
                
                showStatus('Converting to SMF via Rust WASM...', 'info');
                
                // Call Rust WASM to convert parse tree to SMF
                const smfData = parse_tree_json_to_smf(parseTreeStr, mml);
                currentSmfData = smfData;

                // Convert SMF to YM2151 JSON format (simplified)
                const ym2151Json = smfToYM2151Json(smfData);
                document.getElementById('jsonOutput').textContent = JSON.stringify(ym2151Json, null, 2);
                document.getElementById('jsonSection').classList.remove('hidden');

                // Render waveform and prepare audio
                await renderWaveformAndAudio(smfData);

                // Create download link
                const blob = new Blob([smfData], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.mid';
                a.textContent = 'Download MIDI File';

                showStatus('‚úÖ Conversion successful! SMF size: ' + smfData.length + ' bytes', 'success');
                const statusDiv = document.getElementById('status');
                statusDiv.appendChild(document.createElement('br'));
                statusDiv.appendChild(a);

                // Show playback controls
                document.getElementById('playbackControls').style.display = 'block';
                document.getElementById('visualizerSection').style.display = 'block';

            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                console.error('Conversion error:', error);
            }
        };

        // Load example MML
        window.loadExample = function(example) {
            const input = document.getElementById('mmlInput');
            input.value = example;
            // Trigger input event to start automatic conversion
            input.dispatchEvent(new Event('input'));
        };

        // Cleanup debounce timer when page is unloaded
        window.addEventListener('beforeunload', () => {
            if (debounceTimer) {
                clearTimeout(debounceTimer);
                debounceTimer = null;
            }
        });

        // Show status message
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.classList.remove('hidden');
        }

        // Convert SMF to YM2151 JSON format with proper MIDI parsing
        function smfToYM2151Json(smfData) {
            const events = [];

            try {
                if (!smfData || smfData.length < 14) {
                    return { events };
                }

                let offset = 0;

                function readUint32() {
                    if (offset + 4 > smfData.length) {
                        throw new Error('Unexpected EOF while reading uint32');
                    }
                    const value = (smfData[offset] << 24) |
                        (smfData[offset + 1] << 16) |
                        (smfData[offset + 2] << 8) |
                        smfData[offset + 3];
                    offset += 4;
                    return value >>> 0;
                }

                function readUint16() {
                    if (offset + 2 > smfData.length) {
                        throw new Error('Unexpected EOF while reading uint16');
                    }
                    const value = (smfData[offset] << 8) | smfData[offset + 1];
                    offset += 2;
                    return value & 0xffff;
                }

                function readVlq() {
                    let value = 0;
                    let bytesRead = 0;
                    while (true) {
                        if (offset >= smfData.length) {
                            throw new Error('Unexpected EOF while reading VLQ');
                        }
                        const b = smfData[offset++];
                        value = (value << 7) | (b & 0x7f);
                        bytesRead++;
                        if (!(b & 0x80) || bytesRead > 4) {
                            break;
                        }
                    }
                    return value >>> 0;
                }

                // Parse header chunk (MThd)
                if (String.fromCharCode(
                    smfData[0],
                    smfData[1],
                    smfData[2],
                    smfData[3]
                ) !== 'MThd') {
                    throw new Error('Not an SMF file (missing MThd)');
                }

                offset = 4;
                const headerLength = readUint32();
                const formatType = readUint16();
                const numTracks = readUint16();
                const division = readUint16();

                // Skip any remaining header bytes
                if (headerLength > 6) {
                    offset += (headerLength - 6);
                }

                // Default tempo: 500000 microseconds per quarter note (120 BPM)
                let tempoMicrosPerQuarter = 500000;

                function deltaTicksToSeconds(deltaTicks) {
                    if (division === 0) return 0;
                    return (deltaTicks * tempoMicrosPerQuarter) / (division * 1e6);
                }

                // Parse each track chunk (MTrk)
                for (let trackIndex = 0; trackIndex < numTracks; trackIndex++) {
                    if (offset + 8 > smfData.length) break;

                    const id = String.fromCharCode(
                        smfData[offset],
                        smfData[offset + 1],
                        smfData[offset + 2],
                        smfData[offset + 3]
                    );
                    offset += 4;

                    const trackLength = readUint32();
                    const trackEnd = offset + trackLength;

                    if (id !== 'MTrk') {
                        offset = trackEnd;
                        continue;
                    }

                    let currentTimeSeconds = 0.0;
                    let runningStatus = null;

                    while (offset < trackEnd) {
                        const deltaTicks = readVlq();
                        const deltaSeconds = deltaTicksToSeconds(deltaTicks);
                        currentTimeSeconds += deltaSeconds;

                        if (offset >= trackEnd) break;

                        let statusByte = smfData[offset++];

                        if (statusByte < 0x80) {
                            if (runningStatus === null) {
                                throw new Error('Running status without previous status');
                            }
                            offset--;
                            statusByte = runningStatus;
                        } else {
                            runningStatus = statusByte;
                        }

                        // Meta event
                        if (statusByte === 0xff) {
                            if (offset >= trackEnd) break;
                            const metaType = smfData[offset++];
                            const length = readVlq();
                            if (offset + length > trackEnd) {
                                offset = trackEnd;
                                break;
                            }

                            if (metaType === 0x51 && length === 3) {
                                tempoMicrosPerQuarter =
                                    (smfData[offset] << 16) |
                                    (smfData[offset + 1] << 8) |
                                    smfData[offset + 2];
                            }
                            offset += length;
                            continue;
                        }

                        // SysEx events
                        if (statusByte === 0xf0 || statusByte === 0xf7) {
                            const length = readVlq();
                            offset += length;
                            continue;
                        }

                        const statusHighNibble = statusByte & 0xf0;

                        // Determine data length
                        let dataBytesNeeded = 0;
                        if (statusHighNibble === 0xc0 || statusHighNibble === 0xd0) {
                            dataBytesNeeded = 1;
                        } else if (statusHighNibble >= 0x80 && statusHighNibble <= 0xe0) {
                            dataBytesNeeded = 2;
                        } else {
                            break;
                        }

                        if (offset + dataBytesNeeded > trackEnd) break;

                        const data1 = smfData[offset++];
                        const data2 = dataBytesNeeded === 2 ? smfData[offset++] : 0;

                        // Handle Note On/Off
                        if (statusHighNibble === 0x90 || statusHighNibble === 0x80) {
                            const note = data1;
                            let velocity = data2;

                            const isNoteOn = (statusHighNibble === 0x90) && velocity > 0;
                            const isNoteOff = (statusHighNibble === 0x80) || !isNoteOn;

                            if (isNoteOn) {
                                events.push({
                                    time: currentTimeSeconds,
                                    address: 0x08,
                                    data: 0x78
                                });
                                events.push({
                                    time: currentTimeSeconds + 0.001,
                                    address: 0x28,
                                    data: 0x00
                                });
                                events.push({
                                    time: currentTimeSeconds + 0.002,
                                    address: 0x30,
                                    data: (Math.floor(note / 12) << 4) | (note % 12)
                                });
                            } else if (isNoteOff) {
                                events.push({
                                    time: currentTimeSeconds,
                                    address: 0x08,
                                    data: 0x00
                                });
                            }
                        }
                    }

                    offset = trackEnd;
                }
            } catch (e) {
                console.warn('Error parsing MIDI:', e);
            }

            return { events: events };
        }

        // Render waveform and prepare audio
        async function renderWaveformAndAudio(smfData) {
            try {
                // Initialize audio context
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Parse MIDI and generate audio
                const audioData = await midiToAudio(smfData);

                // Create audio buffer
                currentAudioBuffer = audioContext.createBuffer(
                    2,  // stereo
                    audioData.left.length,
                    44100  // sample rate
                );

                currentAudioBuffer.getChannelData(0).set(audioData.left);
                currentAudioBuffer.getChannelData(1).set(audioData.right);

                // Draw waveform
                drawWaveform(audioData.left);

            } catch (error) {
                console.error('Error rendering waveform:', error);
            }
        }

        // Parse MIDI to audio with proper timing
        async function midiToAudio(smfData) {
            const sampleRate = 44100;

            try {
                // Parse MIDI to extract notes with proper timing
                const notes = parseMidiNotes(smfData);

                if (notes.length === 0) {
                    // Return empty audio if no notes
                    const numSamples = Math.floor(sampleRate * 1.0);
                    return {
                        left: new Float32Array(numSamples),
                        right: new Float32Array(numSamples)
                    };
                }

                // Calculate total duration from last note off time, plus buffer
                const maxEndTime = Math.max(...notes.map(n => n.start + n.duration));
                const duration = maxEndTime + 0.5; // Add 0.5s buffer
                const numSamples = Math.floor(sampleRate * duration);

                const left = new Float32Array(numSamples);
                const right = new Float32Array(numSamples);

                // Generate sine waves for each note
                for (const noteInfo of notes) {
                    const freq = 440 * Math.pow(2, (noteInfo.note - 69) / 12);
                    const startSample = Math.floor(noteInfo.start * sampleRate);
                    const durationSamples = Math.floor(noteInfo.duration * sampleRate);

                    for (let i = 0; i < durationSamples; i++) {
                        const sampleIndex = startSample + i;
                        if (sampleIndex < numSamples) {
                            const t = i / sampleRate;
                            const envelope = Math.exp(-3 * t);
                            const value = Math.sin(2 * Math.PI * freq * t) * envelope * noteInfo.velocity * 0.3;

                            left[sampleIndex] += value;
                            right[sampleIndex] += value;
                        }
                    }
                }

                return { left, right };
            } catch (error) {
                console.error('Error in midiToAudio:', error);
                // Return empty audio on error
                const numSamples = Math.floor(sampleRate * 1.0);
                return {
                    left: new Float32Array(numSamples),
                    right: new Float32Array(numSamples)
                };
            }
        }

        // Parse MIDI file to extract note events with proper timing
        function parseMidiNotes(smfData) {
            const notes = [];

            try {
                if (!smfData || smfData.length < 14) {
                    return notes;
                }

                let offset = 0;

                function readUint32() {
                    const value = (smfData[offset] << 24) |
                        (smfData[offset + 1] << 16) |
                        (smfData[offset + 2] << 8) |
                        smfData[offset + 3];
                    offset += 4;
                    return value >>> 0;
                }

                function readUint16() {
                    const value = (smfData[offset] << 8) | smfData[offset + 1];
                    offset += 2;
                    return value & 0xffff;
                }

                function readVlq() {
                    let value = 0;
                    let bytesRead = 0;
                    while (true) {
                        if (offset >= smfData.length) break;
                        const b = smfData[offset++];
                        value = (value << 7) | (b & 0x7f);
                        bytesRead++;
                        if (!(b & 0x80) || bytesRead > 4) break;
                    }
                    return value >>> 0;
                }

                // Parse header
                if (String.fromCharCode(smfData[0], smfData[1], smfData[2], smfData[3]) !== 'MThd') {
                    return notes;
                }

                offset = 4;
                const headerLength = readUint32();
                const formatType = readUint16();
                const numTracks = readUint16();
                const division = readUint16();

                if (headerLength > 6) {
                    offset += (headerLength - 6);
                }

                let tempoMicrosPerQuarter = 500000;

                function deltaTicksToSeconds(deltaTicks) {
                    if (division === 0) return 0;
                    return (deltaTicks * tempoMicrosPerQuarter) / (division * 1e6);
                }

                // Track active notes (note on without note off yet)
                const activeNotes = new Map(); // key: note number, value: {start, velocity}

                for (let trackIndex = 0; trackIndex < numTracks; trackIndex++) {
                    if (offset + 8 > smfData.length) break;

                    const id = String.fromCharCode(smfData[offset], smfData[offset + 1], smfData[offset + 2], smfData[offset + 3]);
                    offset += 4;

                    const trackLength = readUint32();
                    const trackEnd = offset + trackLength;

                    if (id !== 'MTrk') {
                        offset = trackEnd;
                        continue;
                    }

                    let currentTimeSeconds = 0.0;
                    let runningStatus = null;

                    while (offset < trackEnd) {
                        const deltaTicks = readVlq();
                        currentTimeSeconds += deltaTicksToSeconds(deltaTicks);

                        if (offset >= trackEnd) break;

                        let statusByte = smfData[offset++];

                        if (statusByte < 0x80) {
                            if (runningStatus === null) break;
                            offset--;
                            statusByte = runningStatus;
                        } else {
                            runningStatus = statusByte;
                        }

                        // Meta event
                        if (statusByte === 0xff) {
                            if (offset >= trackEnd) break;
                            const metaType = smfData[offset++];
                            const length = readVlq();
                            if (offset + length > trackEnd) {
                                offset = trackEnd;
                                break;
                            }

                            if (metaType === 0x51 && length === 3) {
                                tempoMicrosPerQuarter =
                                    (smfData[offset] << 16) |
                                    (smfData[offset + 1] << 8) |
                                    smfData[offset + 2];
                            }
                            offset += length;
                            continue;
                        }

                        // SysEx
                        if (statusByte === 0xf0 || statusByte === 0xf7) {
                            const length = readVlq();
                            offset += length;
                            continue;
                        }

                        const statusHighNibble = statusByte & 0xf0;

                        let dataBytesNeeded = 0;
                        if (statusHighNibble === 0xc0 || statusHighNibble === 0xd0) {
                            dataBytesNeeded = 1;
                        } else if (statusHighNibble >= 0x80 && statusHighNibble <= 0xe0) {
                            dataBytesNeeded = 2;
                        } else {
                            break;
                        }

                        if (offset + dataBytesNeeded > trackEnd) break;

                        const data1 = smfData[offset++];
                        const data2 = dataBytesNeeded === 2 ? smfData[offset++] : 0;

                        // Handle Note On/Off
                        if (statusHighNibble === 0x90 || statusHighNibble === 0x80) {
                            const note = data1;
                            const velocity = data2;

                            const isNoteOn = (statusHighNibble === 0x90) && velocity > 0;

                            if (isNoteOn) {
                                // Store note start
                                activeNotes.set(note, {
                                    start: currentTimeSeconds,
                                    velocity: velocity / 127.0
                                });
                            } else {
                                // Note off - complete the note
                                if (activeNotes.has(note)) {
                                    const noteStart = activeNotes.get(note);
                                    notes.push({
                                        note: note,
                                        start: noteStart.start,
                                        duration: currentTimeSeconds - noteStart.start,
                                        velocity: noteStart.velocity
                                    });
                                    activeNotes.delete(note);
                                }
                            }
                        }
                    }

                    offset = trackEnd;
                }

                // Handle any notes that didn't get a note-off (give them default duration)
                for (const [note, noteStart] of activeNotes.entries()) {
                    notes.push({
                        note: note,
                        start: noteStart.start,
                        duration: 0.25, // default duration
                        velocity: noteStart.velocity
                    });
                }
            } catch (e) {
                console.warn('Error parsing MIDI notes:', e);
            }

            return notes;
        }

        // Draw waveform on canvas
        function drawWaveform(audioData) {
            const canvas = document.getElementById('waveformCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            ctx.beginPath();

            const step = Math.floor(audioData.length / width);

            for (let i = 0; i < width; i++) {
                const index = i * step;
                const value = audioData[index] || 0;
                const y = (value * 0.5 + 0.5) * height;

                if (i === 0) {
                    ctx.moveTo(i, y);
                } else {
                    ctx.lineTo(i, y);
                }
            }

            ctx.stroke();
        }

        // Play audio with visualization
        window.playAudio = async function() {
            if (!currentAudioBuffer) {
                showStatus('No audio to play. Please convert MML first.', 'error');
                return;
            }

            try {
                // Stop any existing playback
                stopAudio();

                // Start Tone.js context
                await Tone.start();

                // Create player with the prepared AudioBuffer
                const player = new Tone.Player(currentAudioBuffer).toDestination();
                player.loop = false;

                // Create analyzers for visualization
                const waveform = new Tone.Waveform(1024);
                const fft = new Tone.FFT(512);

                player.connect(waveform);
                player.connect(fft);

                // Start playback
                player.start();

                // Update UI
                document.getElementById('playButton').disabled = true;
                document.getElementById('stopButton').disabled = false;

                // Start visualization
                visualizeRealtime(waveform, fft);

                // Re-enable play button when done
                player.onstop = () => {
                    document.getElementById('playButton').disabled = false;
                    document.getElementById('stopButton').disabled = true;
                    if (animationId) {
                        cancelAnimationFrame(animationId);
                        animationId = null;
                    }
                };

                audioSource = player;

            } catch (error) {
                console.error('Error playing audio:', error);
                showStatus('Error playing audio: ' + error.message, 'error');
            }
        };

        // Stop audio playback
        window.stopAudio = function() {
            if (audioSource) {
                try {
                    audioSource.stop();
                } catch (e) {
                    // Ignore errors
                }
                audioSource = null;
            }

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            document.getElementById('playButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
        };

        // Real-time visualization at 60fps
        function visualizeRealtime(waveform, fft) {
            const waveCanvas = document.getElementById('realtimeWaveform');
            const fftCanvas = document.getElementById('realtimeFFT');
            const waveCtx = waveCanvas.getContext('2d');
            const fftCtx = fftCanvas.getContext('2d');

            function draw() {
                // Draw waveform
                const waveformValues = waveform.getValue();
                waveCtx.fillStyle = '#000';
                waveCtx.fillRect(0, 0, waveCanvas.width, waveCanvas.height);

                waveCtx.strokeStyle = '#0f0';
                waveCtx.lineWidth = 2;
                waveCtx.beginPath();

                for (let i = 0; i < waveformValues.length; i++) {
                    const x = i * (waveCanvas.width / waveformValues.length);
                    const y = (1 - (waveformValues[i] + 1) / 2) * waveCanvas.height;

                    if (i === 0) {
                        waveCtx.moveTo(x, y);
                    } else {
                        waveCtx.lineTo(x, y);
                    }
                }
                waveCtx.stroke();

                // Draw FFT
                const fftValues = fft.getValue();
                fftCtx.fillStyle = '#000';
                fftCtx.fillRect(0, 0, fftCanvas.width, fftCanvas.height);

                const barWidth = fftCanvas.width / fftValues.length;

                for (let i = 0; i < fftValues.length; i++) {
                    const value = fftValues[i];
                    const percent = (value + 140) / 140;  // Normalize dB value
                    const barHeight = percent * fftCanvas.height;
                    const hue = (i / fftValues.length) * 360;

                    fftCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                    fftCtx.fillRect(
                        i * barWidth,
                        fftCanvas.height - barHeight,
                        barWidth - 1,
                        barHeight
                    );
                }

                animationId = requestAnimationFrame(draw);
            }

            draw();
        }

        // Export WAV file
        window.exportWav = function() {
            if (!currentAudioBuffer) {
                showStatus('No audio to export. Please convert MML first.', 'error');
                return;
            }

            try {
                const wavData = audioBufferToWav(currentAudioBuffer);
                const blob = new Blob([wavData], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'output.wav';
                a.click();

                // Revoke URL after a short delay to ensure download has started
                setTimeout(() => {
                    URL.revokeObjectURL(url);
                }, 100);
                showStatus('WAV file exported successfully!', 'success');
            } catch (error) {
                console.error('Error exporting WAV:', error);
                showStatus('Error exporting WAV: ' + error.message, 'error');
            }
        };

        // Convert AudioBuffer to WAV format
        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;

            const bytesPerSample = bitDepth / 8;
            const blockAlign = numChannels * bytesPerSample;
            const dataLength = buffer.length * numChannels * bytesPerSample;

            const buffer_out = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer_out);

            // RIFF header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');

            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);  // chunk size
            view.setUint16(20, format, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);  // byte rate
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);

            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            // Write PCM data directly to output buffer
            let offset = 44;
            for (let i = 0; i < buffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = buffer.getChannelData(channel)[i];
                    const intSample = Math.max(-1, Math.min(1, sample));
                    const pcmValue = Math.floor(intSample < 0 ? intSample * 0x8000 : intSample * 0x7FFF);
                    view.setInt16(offset, pcmValue, true);
                    offset += 2;
                }
            }

            return buffer_out;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Initialize on page load
        initialize();
    </script>
</body>
</html>
